\section{Wireless link}\graphicspath{{figures/design/basicsystem/}}
%%%%%%%%%%%%%%%% DISSE KRAV SKAL OPFYLDES I DETTE AFSNIT %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%																		 			%
%				Must have insight into the OSI network model			%
%																		 			%
%			Must have fundamental knowledge of wireless communication		%
%																		 			%
%	Must have knowledge of protocols on various layers in communicating systems	%
%																					%
%			Must be able to use methods for construction of distributed 			%
%			systems making use of communication hardware, multi-					%
%			programming and basic network protocols 								%
%																					%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In order for the rover and the base to interact with each other, a wireless link must be established between the two. Furthermore, there must exist a communication link between the user and the product. The base and the rover will communicate via an ad-hoc network, set up by the base. This is to eliminate any errors caused by the consumers network connection. Confer \autoref{sec:chosolut} it is already decided that the product will implement Wi-Fi for such a link. Wi-Fi is a standard developed by IEEE (IEEE 802.11) and is based on the IEEE 802.3 standard for Ethernet. It specifies how the devices on the network are hooked up and how the communications operates \citep{Woodfi}. To better understand the flow of communication and how the different implementations interact the following topics will be presented: The \gls{osi} model and the \gls{tcp}/\glsentryshort{ip} model.

\subsection{The OSI model}
The \gls{osi} model is a reference model which gives an overview as to how communication should take place during transmission via the network. The model defines a variety of standards and extends from when to and when not to send, to how to make sure the data is sent and received by the appropriate devices. It divides the communication into seven layers and each layer provides service to the layer above and receives services from the layer below. The seven layers of the \gls{osi} model is defined as seen in \autoref{fig:osi}.

When a protocol is developed for network communication, it is placed in one of the seven layers. This is primarily done for two reasons: to help integrate the protocol and to help conceptual understanding of the protocol. A quick overview of the layers and their general functions is seen in \autoref{fig:osi}.

\begin{figure}[h]%
\centering
\includegraphics[width=0.5\textwidth]{osimodel}%
\caption{Overview of the seven layers of the \glsentryshort{osi} model and their general function \citep{tech-faq}.}%
\label{fig:osi}%
\end{figure}

A protocol stack is a group of protocols which is placed in a layer to give that layer its respective functionality. When implementing protocols in real systems, the process is most often as seen in the left column of \autoref{fig:osi}. The data is divided into small segments which are transformed to packets. Addressing is added to the packet so it is known, where and to who it is going. The network hardware on the device will send the packet and at the receiving end, the addressing is read to know which process needs the data and the packets is collected to assemble the original data. Depending on the protocol an acknowledgement signal is sent upon receiving a packet to let the sender know that it arrived correctly \citep{tech-faq}.

\subsection{The TCP/IP model}
The \gls{tcp}/\gls{ip} is a four layer model that describes a set of general guidelines for designing and implementing protocols for network communication. The functionality of this model is basically the same as for the \gls{osi} model. This model has become the de facto standard when implementing network communication in systems. In order to get data from the Reach devices, \gls{tcp} is implemented. This protocol operates in the transport layer of the models, either \gls{osi} or \gls{tcp}. The \gls{tcp} is a connection-oriented protocol. This means that packages are retransmitted if they are lost. For this to be implemented it gives a requirement for acknowledgement signals, which tells the sender that everything sent was received. \gls{tcp}/\gls{ip} is a protocol typically implemented in applications such as email, where it is important that all the data is sent. An alternative to the \gls{tcp} protocol is the \gls{udp}. \gls{udp} operates, like \gls{tcp}, in the third and fourth layer of the \gls{osi} model. There are some major differences in the implementation of \gls{udp} as compared to \gls{tcp}. The biggest difference being that \gls{udp} is a connection-less protocol. This means that the latest package is the most relevant one and retransmission of lost packages is not a priority. This is typically implemented in applications such as chatting, streaming video, etc. In these types of connections, the newest packages are the most important ones.

Included in the Emlid Reach programs based on RTKlib is the option to give the output through the use of \gls{tcp}, either as a server or as a client. It is chosen that the receiver gives its output on a \gls{tcp} server. The process of coding a simple \gls{tcp} server, is not much different from coding a client and because of this, it will only be explained how to create the client. The overall functionality from the client includes being able to establish a connection to the server. Through this connection the client must pull data from the server. In order for the client and server to connect, a socket they can use to connect, must be created. Both the client and the server are written in C. 

\subsection{\glsentryshort{tcp} client}\label{subsec:tcp_client}
When writing a \gls{tcp} client program the first thing to do is to create a socket descriptor. A socket is a way to talk to other programs using the standard file descriptors, but with more control over the transmission. With the inclusion of the standard library \textit{sys.h} a socket can be created as shown in \autoref{code:creatingSocket}.

\includeCode{clienttest.c}{C}{11}{12}{Creating a socket}{code:creatingSocket}{../Kode/clienttest/}

The socket is created with the statement in line 12. It takes three arguments: \textit{domain, type} and \textit{protocol}. \textit{Domain} declares what type of socket is created, in this case PF_INET means an IPv4 socket is created. The \textit{type} determines if the socket will be a \gls{tcp} or an \gls{udp} and when using SOCK_STREAM a \gls{tcp} socket is created. The last argument is to declare which protocol to use and when set to '0' it will automatically choose the proper protocol, in this case, \gls{tcp}. When the socket has been declared there is still some basic structures that must be initialised. A socket must have a struct which holds its port, ip-address and its family. The code is shown in \autoref{code:struct}

\includeCode{clienttest.c}{C}{22}{23}{Initialising a struct for the socket}{code:struct}{../Kode/clienttest/}

The only thing missing in order to be able to connect is the \gls{ip}-address to the destination server. This has to delivered in binary so the computer can read it. To do this, the function \textit{inet_pton} can be used. The function returns '1' if successful, '-1' upon failure and '0' if the input is not a valid IP-address. It takes three arguments: the family, the \gls{ip}-address and the place to store the data. To ensure knowledge of any errors that can occur, the statement is constructed as shown in \autoref{code:ipton}.

\includeCode{clienttest.c}{C}{26}{30}{Declaring the IP-address}{code:ipton}{../Kode/clienttest/}

This ensures that an error message is printed if the function fails and the program will then terminate. When executed successfully the client is ready to connect to a server. This is done with the function, \textit{connect}. It needs three arguments. The socket file descriptor created in \autoref{code:creatingSocket} as the first argument, the data structure created in \autoref{code:struct} containing the server address as the second argument and the length of the address as the third. This is shown in \autoref{code:connecting}

\includeCode{clienttest.c}{C}{32}{36}{Connecting to the server}{code:connecting}{../Kode/clienttest/}

This function is also created with an if-statement to catch any unexpected errors if the function fails. When the connection is established the data on the server can be read with a \textit{read} call, since the socket and thereby the connection is essentially just a file descriptor. When there is no longer a need for the connection to be alive, it must be closed with the \textit{close} command.\\ This is shown in \autoref{code:close}.
\newpage
\includeCode{clienttest.c}{C}{116}{120}{Closing the socket}{code:close}{../Kode/clienttest/}

The data extracted from the Reach devices contains more information than just the coordinates and therefore the data read from the server has to be sorted, so only the relevant information is kept. An example on how the data looks like before sorting is shown in \autoref{fig:example_data}. The part marked in red is an example on three sets of coordinates in X, Y and Z format.

\begin{figure}[h]%
\centering
\includegraphics[width=\textwidth]{reach_data}%
\caption{Example of data pulled from the Reach device. }%
\label{fig:example_data}%
\end{figure}

This is done continuously for as long as the Reach rover has information to send. When retrieving the data from the rover, the program checks the coordinates against the last received data. If the new coordinates are found to be a predefined amount away from the last datapoints, the coordinates are discarded. This can be done, seeing as it is known how far the robot can travel in a given amount of time and if the coordinates are longer away than this, they can be considered invalid. %When the data is found valid the coordinates are printed to a \textit{.csv} file. The current data point is also printed to another file, that is continuously overwritten which results in a file that will always hold the current position.

\section{Log files}\label{sec:LOG}
To store information about warnings and errors in the system, a Log program is constructed. This program adds a function to the system, which allows all programs to write to a Log file. 
Each module of the system will have a separate Log file with the name of the module. Any warnings, errors or information will be added to the file, with date and time. The function is shown in \autoref{cs:log}

From the code it is shown that the Log file will be cleared, if the size is greater than \SI{10}{\mega\byte}, to avoid filling up the flash.
\includeCode{LOG.h}{C}{28}{55}{Construction of Log file.}{cs:log}{../Kode/rou_pla/}

