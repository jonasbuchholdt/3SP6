\section{Drive train controller}

%To produce a stable \gls{pwm} signal for the motors an \gls{fpga} is programmed. This is done in \gls{vhdl} and using a Spartan 6 \gls{fpga} on a Papilio Duo development board.
%
%To be able to control the robot and where it must go, the two motors needs to be given information separately. For this the two motors are separated in the program. This means there are two processes, one for each motor. It is made possible to change the duty cycle of each of the motors separately and thus change the motor speed.
%
%Since the robot might need to drive backwards it is essential to enable this as well. This is done by creating extra cases in each of the motor processes. This gives an idle state, a forward state and a reverse state. 
%
%A \gls{fsm} is made. An \gls{asmd} of this is shown in \autoref{fig:PWM_fsm}.
%
%
%The \gls{fpga} is programmed by \gls{vhdl}
%
%As stated earlier, it is chosen to control the motors by a \gls{pwm} signal. The \gls{pwm} signal is generated by an \gls{fpga} 

To allow the Intel Edison to control the drive train an intermediate controller is developed on an \gls{fpga}. The controller must be able to receive the three bytes from the Intel Edison. The \gls{fpga} is thereby controlled by the Edison. In \autoref{fig:main_unit} is an overview of the system running on the \gls{fpga}. 


\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{main_unit}
    %\missingfigure{\gls{pwm} module \gls{fsm} diagram}
    \caption{General overview of the system on the \gls{fpga} with interconnections. All modules are connected to the system clock and a reset signal. The white circles indicate inputs and circles with a black dot indicate outputs.}
    \label{fig:main_unit}
\end{figure}
    
The system in \autoref{fig:main_unit} consist of three unique blocks where two of the blocks are duplicated to handle each motor. The top block receives and process the messages form the Edison. The signals from the \textit{msg_handler} is used in two state machines, one for each motor, and a \gls{pwm} signal is delivered according to the received messages. 

\subsection{Message handler}
The message handler on the \gls{fpga} is built around a \gls{fsm} as seen in \autoref{fig:msg_handler_unit}. The \gls{fsm} gets input from a \gls{uart} module, described in \autoref{sec:serial_comm}. A \textit{watchdog} block makes sure to reset the message handler if no valid messages is received within \SI{30}{\milli\second}. Upon reset of the block all outputs to enable the \gls{pwm} signal is set to low.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{msg_handler_unit}
    %\missingfigure{\gls{pwm} module \gls{fsm} diagram}
    \caption{General overview of the message handler block on the \gls{fpga} with interconnections. All modules are connected to the system clock and a reset signal. Two registers for the right motor control is cut from the figure as they are identically to their left counter parts. The white circles indicate inputs and circles with a black dot indicate outputs.}
    \label{fig:msg_handler_unit}
\end{figure}

\begin{figure}[h]%
\centering%
\includegraphics[width=1\columnwidth]{msg_handler_state_machine}%
\caption{\glsentryshort{asmd} chart of the \gls{fsm} of the message handler block. The states to control the right motor is omitted on the figure as they are identically as states for the left motor.}%
\label{fig:msg_handler_state_machine}%
\end{figure}

The  message handler gets data from the \gls{uart} block byte wise and compares them against known commands while changing state accordingly. The conditions for state change and outputs is shown on the \gls{asmd} chart on \autoref{fig:msg_handler_state_machine}.

\subsection{\glsentryshort{pwm} generator}
The \gls{pwm} generator is derived from \cite{larson2015}. The code details a \gls{pwm} generator programmable logic component for a \gls{fpga} written in \gls{vhdl}. This component gives an output based on the the duty cycle given by the user. The given program gives the user the ability to make several outputs from one component but with different phases. This has been excluded from the program, as this is not needed.

The program only uses two \textit{if} statements and a counter to generate the \gls{pwm} signal. To change the switching frequency a constant is set in the \gls{vhdl} code.


\subsection{State processes}
The two state processes controls the output of the \gls{pwm} signals based on the signals from the message handler block. In \autoref{fig:motor_control_state_machine} is an \gls{asmd} chart for one state process. The two processes operates in the same way: All \gls{pwm} signals are turned off in \textit{idle} state. If the message handler signals to either enable forward or reverse drive, the state is change accordingly. 


\begin{figure}[h]%
\centering%
\includegraphics[width=0.9\columnwidth]{motor_control_state_machine}%
\caption{\glsentryshort{asmd} chart of the \glsentryshortpl{fsm} that controls the output of the \glsentryshort{pwm} signal.}%
\label{fig:motor_control_state_machine}%
\end{figure}